\documentclass[a4paper]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[utf8x]{inputenc}
\usepackage{amsmath,amsthm}
\usepackage{multirow}

\title{Криптография, Лекция № 10}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{claim}{Claim}
\newtheorem{idea}{Idea}     
\newtheorem{example}{Example} 
      
\begin{document}
\maketitle

\noindent Продолжаем разговор о протоколах электронной подписи с открытым ключом.
Две стороны подписывающий, проверяющий, у подписывающего есть закрытый ключ, у проверяющего - открытый.
Хотим уметь проверять подпись подписывающего; неправильную подпись хотим уметь почти наверное отвергать.
Сегодня поговорим о кодировании сообщений произвольной длины.~\\

\begin{idea} (Одноразового протокола)~\\
	Вводится семейство хэш-функций:
	$$
		h_s\colon \{0, 1\}^{*} \rightarrow \{0, 1\}^{l(n)}	
	$$
	$S$ вычисляет $h_s(x)$. Открытый ключ - $(e, s)$, закрытый ключ - $(d, s)$.
	Подпись - пара $(h_s(x),\ \textup{подпись под} h_s(x) \textup{при помощи ключа }d)$.
	Если враг сумел взломать подпись, то либо он смог взломать хэш-функцию(нашел коллизию),
	либо взломал вторую подпись.
\end{idea}

\begin{idea} (Многоразового протокола ("с памятью"))~\\
	Вместе с каждым сообщением посылается открытый ключ для проверки
	следующего сообщения. Тогда получается, если взломщик взломал такую подпись,
	то он либо взломал одноразовую подпись, либо взломал генерацию ключей.
	Если мы подписываем биты одного сообщения, то взломщик мог подписать префикс сообщения.
	Для избежания этого можно использовать бесперфиксное кодирование. Схема:
	(слово $\rightarrow$ беспрефиксный код $\rightarrow$ сообщения
	фиксированной длины $\rightarrow$ посылка).
\end{idea}

\begin{definition} (Семейства хэш-функций с трудно отыскиваемыми коллизиями (collision-free))
	По номеру функции трудно найти $x, x'$, такие, что значения на них соответсвующей функции
	совпадают.
	$$
		\forall C_n\ \forall p\ \forall^{\infty} n\ Pr_s\{C_n(s) = (x, x')\colon h_s(x) = h_s(x')\} < \frac{1}{p(n)}	
	$$
	где $C_n$ - схема полиномиального размера. $s \in \{0, 1\}^{k(n)}$, где $k(n)$ - некоторый полином.
	Вероятность берется по некоторому априорному распределению, такому же как и в протоколе.
\end{definition}

\begin{claim}~\\
	Такого семейства достаточно для надежной схемы электронной подписи одного сообщения
	произвольной длины.
\end{claim}

\noindent Если есть взломщик подписи, имеющий открытый ключ $e$, идекс функции $s$.
Генерирует $x$, получает $h_s(x)$ и подпись под $h_s(x)$, генерирует $x'$ и фальшивую подпись.~\\

\noindent $C_n$ получает $s$, генерирует пару $(d, e)$, генерирует $x$, генерирует $h_s(x)$
и подпись при помощи $d$, генерирует $x'$ как взломщик и фальшивую подпись.~\\

\noindent Либо $x \ne x'$ и $h_s(x) = h_s(x')$, тогда взломали хэш-функцию, либо
$h_s(x) \ne h_s(x')$ тогда взломали электронную подпись.~\\

\noindent Откуда можно брать такие семейства функций?

\begin{definition}
	$$
		f_s^0\colon \{0, 1\}^{m(n)} \rightarrow \{0, 1\}^{l(n)}	
	$$
	$$
		f_s^1\colon \{0, 1\}^{m(n)} \rightarrow \{0, 1\}^{l(n)}	
	$$
	Зацепление в системе $\{f_s\}$ - пара $(x, y)$ такая, что $f_s^0(x) = f_s^1(y)$.
\end{definition}

\begin{definition} (Семейства функций с трудно отыскиваемыми зацеплениями (claw-free))
	$$
		\forall C_n\ \forall p\ \forall^{\infty} n\ Pr_s\{C_n(s) = (x, y)\colon (x, y) - \textup{зацепление}\} < \frac{1}{p(n)}	
	$$
\end{definition}

\begin{claim}~\\
	По системе с трудно отыскиваемыми зацеплениями можно построить систему с трудно
	отыскиваемыми коллизиями.
\end{claim}

\begin{proof}~\\
	$x \mapsto \hat{x}$ - беспрефиксный код. Для любого кодового слова $\beta_s \in D_s$.
	$$
		h_s(x) = f_s^{\hat{x}_1}(f_s^{\hat{x}_2}(\ldots (f_s^{\hat{x}_p}(\beta_s))\ldots))	
	$$
	$$
		h_s(x) = h_s(x'), x \ne x' \Rightarrow \exists i\ \hat{x}_i \ne \hat{x}'_j	
	$$
\end{proof}

\begin{claim}~\\
	По "односторонней" функции Рабина можно построить систему функций с трудно
	отыскиваемыми зацеплениями.
\end{claim}

\begin{proof}~\\
	$$
		f_{x, m}^0(y) = x \cdot y^2\ (mod\ m)	
	$$
	$$
		f_{x, m}^1(y) = y^2\ (mod\ m)	
	$$
	Если $f_{x, m}^0(y) = f_{x, m}^1(z)$, то $x\cdot y^2 = z^2\ (mod\ m)$.
	Отсюда $(\frac{z}{y})^2 = x$, можно извлечь корень и получить противоречие с необратимостью
	функции Рабина.
\end{proof}

\section{Альтернативные концепции хэш-функций}

\begin{definition} (Универсальное семейство односторонних хэш-функций)~\\
	$$
		h_s\colon \{0, 1\}^{p(n)} \rightarrow \{0, 1\}^n	
	$$
	Отличие в полиноме.
\end{definition}

\noindent Еще одно отличие - ограничение на поиск коллизий
\begin{definition} (Семейства универсальных хэш-функций с трудно отыскиваемыми коллизиями)
	$$
		\forall C_n\ \forall p\ \forall \{x_n\}\ \forall^{\infty} n\ Pr_s\{h_s(x_n) = h_s(C_n(s))\} < \frac{1}{p(n)}	
	$$
\end{definition}

\noindent То есть универсальное семейство - более слабая концепция.

\begin{theorem} (б/д)~\\
	Если существует односторонняя функция, то существует универсальное семейство.
\end{theorem}

\begin{theorem} (б/д)~\\
	Если существует односторонняя перестановка, то существует универсальное семейство.
\end{theorem}

\subsection{Конструкция одноразовой подписи одного сообщения произвольной длины на базе универсального семейства}

Идея такая, как мы обсуждали в начале. Есть $(S, V)$ - протокол надежной
одноразовой подписи сообщения длины $n + 1$. Строим $(\hat{S}, \hat{V})$.
$\hat{S}$ генерирует $(e_2, d_2), \ldots, (e_m, d_m)$. Исходные ключи - $(d, s), (e, s)$.
Подпись под $(\sigma_1 \ldots \sigma_m)$:
$$
	(e_2, e_3, \ldots, e_n, S(d, h_s(e_2)\sigma_1), S(d_2, h_s(e_3)\sigma_2), \ldots, S(d_m ,h_s(e_{m + 1})\sigma_m))
$$
































\end{document}
