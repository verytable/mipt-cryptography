\documentclass[a4paper]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[utf8x]{inputenc}
\usepackage{amsmath,amsthm}
\usepackage{multirow}

\title{Криптография, Лекция № 6}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{claim}{Claim}
\newtheorem{idea}{Idea}     
\newtheorem{example}{Example} 
      
\begin{document}
\maketitle

\section{Шифрование с закрытым ключом~\\(симметричное)}

Схема:
$$
	x \longrightarrow S \longrightarrow R \longrightarrow x
$$
$S$ и $R$ знают ключ $d$. На второй строчке есть еще $A$ (Ева), который пытается что-то узнать об $x$. Он ничего
не должен узнать об $x$, а точнее он может узнать только то, что он мог бы узнать без входа.~\\

\noindent Формально:
\begin{definition}~\\
	$d = D(1^n)$, $D$ - генератор ключей, вероятностный полиномиальный алгоритм.~\\
	$m = E(x, d)$ - алгоритм шифрования, вероятностный полиномиальный алгоритм.~\\
	$y = D(m, d)$ - алгоритм дешифрования, вероятностный полиномиальный алгоритм.~\\
	Условине корректности: $Pr\{D(E(x, d), d) = x\} \simeq 1$, где $\simeq$ означает стремление
	быстрее любого полинома.~\\
	Условие надежности: $E(x, d)$ и $E(x', d)$ вычислительно не отличимы.
\end{definition}

\noindent Любая пара протоколов, для которых это верно будет называться схемой шифрования с закрытым ключом.~\\

\noindent Гаммирование (one-time pad): $E(x, d) = x \oplus D$, $D(m, d) = m \oplus d$, $|d| = |x|$.
Выполнение условий корректности и надежности проверяется лекго. Проблема в длине ключа. И в том, что схема
одноразовая, ибо если зашифровать $x$ и $y$, то станет известна побитовая сумма $x$ и $x'$.~\\

\noindent Гаммирование с генератором псевдо-случайных чисел: $E(x, d) = x \oplus G(d)$, $D(m, d) = m \oplus G(d)$. Здесь $|x| = poly(|d|)$. Но схема по-прежнему одноразовая.
Чтобы сделать многоразовую схему можно вязть генератор отображающий $n$ бит в $20n$.~\\

\noindent Недостаток шифрования с закрытым ключом: нужен закрытый канал, для передачи ключа.

\section{Шифрование с открытым ключом~\\(асиметричное)}

\noindent Есть два ключа: $e$ - для шифрования и $d$ - для дешифрования. $e$ известнен $A$.
$R$ генерирует пару ключей $e$ и $d$ и публикует ключ $e$. И предлагает шифровать сообщения себе этим
ключом.~\\

\noindent Условие корректности: $Pr\{D(E(x, e), d) = x\} \simeq 1$.~\\
Условие надежности: $(e, E(x, e))$ и $(e, E(x', e))$ вычислительно не отличимы.~\\

\noindent Инструмент: одностороние перестановки с секретом (trapdoor one-way permutations).
В одну сторону их вычислить легко, в другую - трудно, но легко с секретом.~\\

\noindent Формально:
\begin{definition}~\\
	4 функции:
	\begin{itemize}
		\item $K$ - генератор номера функции и секрета
		\item $S$ - выбор случайной точки $0.0$
		\item $F$ - вычисление значение функции
		\item $B$ - при известном значении секрета вычисляет преобразования
	\end{itemize}
	Все эти функции полиномиальные, две из них обязательно вероятностные.
\end{definition}

\begin{theorem}~\\
	Если существует одностороняя перестановка с секретом, то существует односторонняя перестановка
	с секретом и трудным битом.
\end{theorem}

\begin{remark}~\\
	Теорема доказывается аналогично теоремы с прошлого занятия (секрет останется тем же самым).
\end{remark}

\noindent Примеры (предположительные):
\begin{enumerate}
	\item Функция Рабина~\\
		$x \mapsto x^2 (mod\ pq)$, где $p, q$ - простные числа вида $4k + 3$, $x$ - квадратичный вычет.~\\
		Открытый ключ - $p * q$, закрытый ключ - $(p, q)$.~\\
		Если секрет известен, то по $z = x^2$ можно восстановить $x$. А $x = t^2$. Поэтому
		$z^{\frac{p + 1}{4}} = t^{p + 1} \equiv t^2 \equiv x (mod\ p)$~\\
		$z^{\frac{q + 1}{4}} \equiv x (mod\ q)$. Из последних двух сравнений по
		китайской теореме об остатках можно найти $x$.
		
	\item Функция RSA:~\\
		$x \mapsto x^z (mod\ pq)$, где $p, q$ - простые, $(z, \varphi(pq)) = 1$~\\
		Секрет $u$ берем из $z\cdot u = 1\ (mod\ \varphi(p, q))$~\\
		$(x^z)^u = x^{x\cdot u} = x^{\varphi(pq)\cdot k + 1} \equiv x\cdot 1^k = x\ (mod pq)$
\end{enumerate}

\noindent Оба примера основываются на том, что предположительно нельзя быстро раскладывать
на простые множители.~\\

\noindent Построение схемы шифрования с открытым ключом:~\\
$1$ бит $b \in \{0, 1\}$. Пусть $q_{\alpha}(x)$ - одностороняя перестановка с секретом,~\\
$h_{\alpha}(x)$ - трудный бит для этой перестановки.
$$
	b \mapsto (g_{\alpha(x)}, h_{\alpha}(x) \oplus b)
$$

\noindent Проверим условие надежности:~\\
$(g_{\alpha(x)}, h_{\alpha}(x) \oplus b)$ - псевдо-случайная строка длины $n + 1$ (ибо если $h_{\alpha}$ - трудный бит, то и $h_{\alpha} \oplus 1$ - трудный бит)~\\
Если много битов:~\\
$$
	b_1, \ldots, b_k \mapsto (b_1 \oplus h_{\alpha}(x), b_1 \oplus h_{\alpha}(g_{\alpha}(x))), \ldots, b_k \oplus h_{\alpha}(g_{\alpha}^{k - 1}(x), g_{\alpha}^k(x))
$$
Доказательство надежности похоже на доказательство вычислимой неотличимости в генераторах.
Нужно идти с конца.

\end{document}
