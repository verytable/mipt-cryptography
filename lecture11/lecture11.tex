\documentclass[a4paper]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[utf8x]{inputenc}
\usepackage{amsmath,amsthm}
\usepackage{multirow}

\title{Криптография, Лекция № 11}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{claim}{Claim}
\newtheorem{idea}{Idea}     
\newtheorem{example}{Example} 
      
\begin{document}
\maketitle

\section{Надежный протокол электронной подписи полиномиального числа слов полиномиальной длины без памяти}

\begin{idea}~\\
	Изначально есть два ключа: закрытый - $d$ и открытый - $e$.
	$S$ может подписать пару $e_0e_1$ ключом $d$.
	затем подписать $e_{00}e_{01}$ ключом $d_0$ и $e_{10}e_{11}$ ключом $d_1$.
	За $n$ шагов можно получить $2^n$ пар ключей.
	Когда нужна новая подпись, $S$ выбирает случайный из сгенерированных $2^n$ один ключ и 
	подписывает им сообщение.~\\
	
	\noindent Например, выпало $0100$, тогда $S$ пошлет $e_0e_1$ подписанные ключом $d$,
	$e_{00}e_{01}$ - ключом $d_0$, $e_{010}e_{011}$ - $d_{01}$, $e_{0100}e_{0101}$ - $d_{010}$,
	$x$ - $d_{0100}$. Итого, подписывание происходит только по одной ветке.
	Почему мы подписываем пары? Потому, что второй мы уже не сможем отпарвить.
	$e_{\alpha}$ генерируются псевдослучайно, номер функции - часть закрытого ключа.
\end{idea}

\noindent Формально
\begin{definition}~\\
	$(K, S, V)$ - протокол надежной подписи одного сообщения произвольной длины.
	$K$ - генератор ключей, $S$ - подписывающий, $V$ - верификатор.
	$(\bar{K}, \bar{S}, \bar{V})$ - требуемый протокол.
	\begin{enumerate}
		\item Определим $\bar{K}$:~\\
			$\bar{d} = (d, s)$, $\bar{e} = e$,
			$s$ - идентификатор псевдослучайной функции
			из $\{0, 1\}^{*} \mapsto \{0, 1\}^{l(n)}$,
			$e(n)$ - число случайных битов, которые использует~$K$.
		\item $\bar{S}$:~\\
			$\bar{S}$ получает $\bar{d}$ и $x$. Выбирает случайное $\alpha$ длины $n$.
			Для всех префиксов $\beta \subset \alpha$
			генерирует $(e_{\beta0}, d_{\beta0})$ и $(e_{\beta1}, d_{\beta1})$
			при помощи $K$ и $f_s(\beta0)$ и $f_s{\beta1}$ в качестве случайных битов.
			Также $e_{\varepsilon} = e$ и $d_{\varepsilon} = d$, где через $\varepsilon$
			обозначено пустое слово.
			$$
				\bar{S}(\bar{d}, x) = (e_0e_1, S(d, e_0e_1), \ldots, e_{\beta0}e_{\beta1}, S(d_{\beta}, e_{\beta0}e_{\beta1}), \ldots, S(d_{\alpha}, x))
			$$
		\item $\bar{V}$ проверяет подпись естественным образом.
	\end{enumerate}
\end{definition}

\noindent Корректность протокола очевидна. Надежность: с экспоненциально малой вероятностью
могут выпасть одинаковые $\alpha$ для разных $x$-ов. Так что можно считать, что
такого не происходит. Далее, можно считать, что ПСФ алгоритм имеет доступ к случайному оракулу то есть
все пары $(d_{\alpha}, e_{\alpha})$ генерируются независимо друго от друга алгоритмом $K$.~\\

\noindent Пусть схема $C$ взламывает $(\bar{K}, \bar{S}, \bar{V})$
с вероятностью $\varepsilon > \frac{1}{poly(n)}$. Как использовать эту схему для взлома исходного
протокола? $C$ получает $e$, адаптивно генерирует $x_1, \ldots, x_n$ получает подписи
$\bar{s}_1, \ldots, \bar{s}_n$ генерирует $x'$ и подпись $s'$, такие, что
$\bar{V}(s', x') = 1$ с вероятностью $\varepsilon$. Будем говорить, что слово $\alpha$ использованное,
если $\bar{S}$ в ходе атаки $C$ сгенерировал пару $(e_{\alpha}, d_{\alpha})$.
Будем говорить, что $\alpha$ особое, если оно использованное и к тому же,
$e_{\alpha} = e_{\alpha}'$, где $e_{\alpha}'$ - элемент $S'$, а ключ $d_{\alpha}$
не использовался для подписи соответсвующего сообщения из $s'$.
Если атака была успешна, то особые $\alpha$ точно существуют.
В процессе подписи $x_1, \ldots, x_m$ некоторое полиномиальное число раз запускается
исходная $S$. Как теперь взломать $S$ (ключ $e$)? Нужно в одном из этих запусков
заменить ключ на $e$. Тут очень важно, что мы уже перешли к случайному оракулу.~\\

\noindent Здесь должна быть картинка со схемами.

\end{document}
